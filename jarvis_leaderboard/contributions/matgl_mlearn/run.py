# -*- coding: utf-8 -*-
"""Matgl_mlearn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/knc6/jarvis-tools-notebooks/blob/master/jarvis-tools-notebooks/Matgl_mlearn.ipynb
"""

pip install -q matgl

import os
if not os.path.exists('jarvis_leaderboard'):
  !git clone https://github.com/usnistgov/jarvis_leaderboard.git
os.chdir('jarvis_leaderboard')
!pip install -e .

!pip install numpy==1.23.5
# then restart session

!wget https://figshare.com/ndownloader/files/40357663 -O mlearn.json.zip

import json,zipfile
mlearn = json.loads(
        zipfile.ZipFile("mlearn.json.zip").read(
            "mlearn.json"
        )
    )

# Commented out IPython magic to ensure Python compatibility.
# %%time
# import os
# from jarvis.core.atoms import Atoms
# import os
# import shutil
# import warnings
# 
# import numpy as np
# import pytorch_lightning as pl
# from dgl.data.utils import split_dataset
# #from mp_api.client import MPRester
# from pytorch_lightning.loggers import CSVLogger
# import numpy as np
# import torch
# from matgl.apps.pes import Potential
# import zipfile,json, glob
# import pandas as pd
# import matgl
# from matgl.ext.pymatgen import Structure2Graph, get_element_list
# from matgl.graph.data import M3GNetDataset, MGLDataLoader, collate_fn_efs
# from matgl.models import M3GNet
# from matgl.utils.training import PotentialLightningModule
# 
# # To suppress warnings for clearer output
# warnings.simplefilter("ignore")
# 
# os.chdir('/content')
# elements = ['Si']
# max_epochs=100
# models={}
# for element in elements:
# 
#     benchmark_energies = (
#         "jarvis_leaderboard/jarvis_leaderboard/benchmarks/AI/MLFF/mlearn_"
#         + element
#         + "_energy.json.zip"
#     )
#     temp_energies = benchmark_energies.split("/")[-1].split(".zip")[0]
#     energies = json.loads(
#         zipfile.ZipFile(benchmark_energies).read(temp_energies)
#     )
#     train_ids = list(energies["train"].keys())
#     test_ids = list(energies["test"].keys())
# 
#     train_energies=[]
#     train_forces=[]
#     train_stresses=[]
#     train_structures=[]
#     for i in mlearn:
#         if i["jid"] in train_ids:
#             # print(i)
#             train_energies.append(i["energy"])
#             train_forces.append(i["forces"])
#             train_stresses.append(i['stresses'])
#             atoms = Atoms.from_dict(i["atoms"])
#             train_structures.append(atoms.pymatgen_converter())
# 
# 
#     labels = {
#         "energies": train_energies,
#         "forces": train_forces,
#         "stresses": train_stresses,
#     }
# 
# 
# 
#     element_types = get_element_list(train_structures)
#     converter = Structure2Graph(element_types=element_types, cutoff=5.0)
#     train_data = M3GNetDataset(
#         threebody_cutoff=4.0,
#         structures=train_structures,
#         converter=converter,
#         labels=labels,
#     )
# 
# 
#     test_energies=[]
#     test_forces=[]
#     test_stresses=[]
#     test_structures=[]
#     tids = []
#     for i in mlearn:
#         if i["jid"] in test_ids:
#             # print(i)
#             test_energies.append(i["energy"])
#             test_forces.append(i["forces"])
#             test_stresses.append(i['stresses'])
#             atoms = Atoms.from_dict(i["atoms"])
#             test_structures.append(atoms.pymatgen_converter())
#             tids.append(i['jid'])
# 
#     labels = {
#         "energies": test_energies,
#         "forces": test_forces,
#         "stresses": test_stresses,
#     }
# 
# 
# 
#     element_types = get_element_list(test_structures)
#     converter = Structure2Graph(element_types=element_types, cutoff=5.0)
#     test_data = M3GNetDataset(
#         threebody_cutoff=4.0,
#         structures=test_structures,
#         converter=converter,
#         labels=labels,
#     )
# 
# 
#     train_loader, val_loader, test_loader = MGLDataLoader(
#         train_data=train_data,
#         val_data=test_data,
#         test_data=test_data,
#         collate_fn=collate_fn_efs,
#         batch_size=2,
#         num_workers=1,
#     )
#     model = M3GNet(
#         element_types=element_types,
#         is_intensive=False,
#     )
#     lit_module = PotentialLightningModule(model=model)
# 
# 
# 
#     logger = CSVLogger("logs", name="M3GNet_training")
#     # Inference mode = False is required for calculating forces, stress in test mode and prediction mode
#     trainer = pl.Trainer(max_epochs=max_epochs, accelerator="cpu", logger=logger, inference_mode=False)
#     trainer.fit(model=lit_module, train_dataloaders=train_loader, val_dataloaders=val_loader)
#     models[element]=trainer
#     trainer.test(dataloaders=test_loader)
# 
#     ######
# 
#     def get_matgl_pred(atoms=None,model=None):
#         element_types = get_element_list([atoms.pymatgen_converter()])
#         p2g = Structure2Graph(element_types=element_types, cutoff=5.0)
#         graph, lat, state = p2g.get_graph(atoms.pymatgen_converter())
#         ff = Potential(model=model, calc_hessian=False)
#         e, f, s, h = ff(graph, lat, torch.tensor(state))
#         return e.detach().numpy(),f.detach().numpy(),s.detach().numpy()
# 
#     df = pd.DataFrame(
#         json.loads(
#             zipfile.ZipFile("mlearn.json.zip").read(
#                 "mlearn.json"
#             )
#         )
#     )
#     print(df)
#     i_model = trainer.model.model.model
#     for i in glob.glob("/content/jarvis_leaderboard/jarvis_leaderboard/benchmarks/AI/MLFF/*energy*.zip"):
#         if "mlearn" in i and element in i:
#             fname_e = (
#                 "AI-MLFF-energy-"
#                 + i.split("/")[-1].split("_energy.json.zip")[0]
#                 + "-test-mae.csv"
#             )
#             fname_f = (
#                 "AI-MLFF-forces-"
#                 + i.split("/")[-1].split("_energy.json.zip")[0]
#                 + "-test-multimae.csv"
#             )
#             fname_s = (
#                 "AI-MLFF-stresses-"
#                 + i.split("/")[-1].split("_energy.json.zip")[0]
#                 + "-test-multimae.csv"
#             )
#             f_e = open(fname_e, "w")
#             f_f = open(fname_f, "w")
#             f_s = open(fname_s, "w")
# 
#             f_e.write("id,prediction\n")
#             f_f.write("id,prediction\n")
#             f_s.write("id,prediction\n")
# 
#             print(i)
#             dat = json.loads(
#                 zipfile.ZipFile(i).read(i.split("/")[-1].split(".zip")[0])
#             )
#             print(dat["test"])
#             for key, val in dat["test"].items():
#                 entry = df[df["jid"] == key]
#                 atoms = Atoms.from_dict(entry.atoms.values[0])
#                 # print(key,val,df[df['jid']==key],atoms)
#                 # energy,forces=get_alignn_forces(atoms)
#                 energy, forces, stress = get_matgl_pred(atoms=atoms,model=i_model)
#                 print(key, val, energy, atoms.num_atoms)
#                 line = key + "," + str(energy) + "\n"
#                 f_e.write(line)
#                 line = (
#                     key
#                     + ","
#                     + str(";".join(map(str, np.array(forces).flatten())))
#                     + "\n"
#                 )
#                 f_f.write(line)
#                 line = (
#                     key
#                     + ","
#                     + str(";".join(map(str, np.array(stress).flatten())))
#                     + "\n"
#                 )
#                 f_s.write(line)
#             f_e.close()
#             f_f.close()
#             f_s.close()
#             zname = fname_e + ".zip"
#             with zipfile.ZipFile(zname, "w") as myzip:
#                 myzip.write(fname_e)
# 
#             zname = fname_f + ".zip"
#             with zipfile.ZipFile(zname, "w") as myzip:
#                 myzip.write(fname_f)
# 
#             zname = fname_s + ".zip"
#             with zipfile.ZipFile(zname, "w") as myzip:
#                 myzip.write(fname_s)
# 
# 
# # x=[]
# # y=[]
# # i_model = trainer.model.model.model
# # for i,j,k in zip(test_structures,test_energies,tids):
# 
# #     e, f, s, h = get_matgl_pred(structure=i,model=i_model)
# #     #pen = trainer.model.model.model.predict_structure(i)
# #     nat = len(i)
# #     print(j,e)
# #     x.append(j/nat)
# #     y.append(e/nat)
# # x = np.array(x)
# # y = np.array(y)
# # from sklearn.metrics import mean_absolute_error
# # mean_absolute_error(x,y)
# 
#

!ls

# import numpy as np
# import torch
# from matgl.apps.pes import Potential
# import zipfile,json, glob
# import pandas as pd
# def get_matgl_pred(atoms=None,model=None):
#     element_types = get_element_list([atoms.pymatgen_converter()])
#     p2g = Structure2Graph(element_types=element_types, cutoff=5.0)
#     graph, lat, state = p2g.get_graph(atoms.pymatgen_converter())
#     ff = Potential(model=model, calc_hessian=False)
#     e, f, s, h = ff(graph, lat, torch.tensor(state))
#     return e.detach().numpy(),f.detach().numpy(),s.detach().numpy()

# df = pd.DataFrame(
#     json.loads(
#         zipfile.ZipFile("mlearn.json.zip").read(
#             "mlearn.json"
#         )
#     )
# )
# print(df)
# i_model = trainer.model.model.model
# for i in glob.glob("/content/jarvis_leaderboard/jarvis_leaderboard/benchmarks/AI/MLFF/*energy*.zip"):
#     if "mlearn" in i and element in i:
#         fname_e = (
#             "AI-MLFF-energy-"
#             + i.split("/")[-1].split("_energy.json.zip")[0]
#             + "-test-mae.csv"
#         )
#         fname_f = (
#             "AI-MLFF-forces-"
#             + i.split("/")[-1].split("_energy.json.zip")[0]
#             + "-test-multimae.csv"
#         )
#         fname_s = (
#             "AI-MLFF-stresses-"
#             + i.split("/")[-1].split("_energy.json.zip")[0]
#             + "-test-multimae.csv"
#         )
#         f_e = open(fname_e, "w")
#         f_f = open(fname_f, "w")
#         f_s = open(fname_s, "w")

#         f_e.write("id,prediction\n")
#         f_f.write("id,prediction\n")
#         f_s.write("id,prediction\n")

#         print(i)
#         dat = json.loads(
#             zipfile.ZipFile(i).read(i.split("/")[-1].split(".zip")[0])
#         )
#         print(dat["test"])
#         for key, val in dat["test"].items():
#             entry = df[df["jid"] == key]
#             atoms = Atoms.from_dict(entry.atoms.values[0])
#             # print(key,val,df[df['jid']==key],atoms)
#             # energy,forces=get_alignn_forces(atoms)
#             energy, forces, stress = get_matgl_pred(atoms=atoms,model=i_model)
#             print(key, val, energy, atoms.num_atoms)
#             line = key + "," + str(energy) + "\n"
#             f_e.write(line)
#             line = (
#                 key
#                 + ","
#                 + str(";".join(map(str, np.array(forces).flatten())))
#                 + "\n"
#             )
#             f_f.write(line)
#             line = (
#                 key
#                 + ","
#                 + str(";".join(map(str, np.array(stress).flatten())))
#                 + "\n"
#             )
#             f_s.write(line)
#         f_e.close()
#         f_f.close()
#         f_s.close()
#         zname = fname_e + ".zip"
#         with zipfile.ZipFile(zname, "w") as myzip:
#             myzip.write(fname_e)

#         zname = fname_f + ".zip"
#         with zipfile.ZipFile(zname, "w") as myzip:
#             myzip.write(fname_f)

#         zname = fname_s + ".zip"
#         with zipfile.ZipFile(zname, "w") as myzip:
#             myzip.write(fname_s)


# # x=[]
# # y=[]
# # i_model = trainer.model.model.model
# # for i,j,k in zip(test_structures,test_energies,tids):

# #     e, f, s, h = get_matgl_pred(structure=i,model=i_model)
# #     #pen = trainer.model.model.model.predict_structure(i)
# #     nat = len(i)
# #     print(j,e)
# #     x.append(j/nat)
# #     y.append(e/nat)
# # x = np.array(x)
# # y = np.array(y)
# # from sklearn.metrics import mean_absolute_error
# # mean_absolute_error(x,y)

